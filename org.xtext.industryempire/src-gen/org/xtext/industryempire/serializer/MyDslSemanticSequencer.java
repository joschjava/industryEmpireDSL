/*
 * generated by Xtext 2.13.0
 */
package org.xtext.industryempire.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.industryempire.myDsl.Cities;
import org.xtext.industryempire.myDsl.ClazzModel;
import org.xtext.industryempire.myDsl.Factories;
import org.xtext.industryempire.myDsl.MyDslPackage;
import org.xtext.industryempire.myDsl.Resources;
import org.xtext.industryempire.myDsl.SingleFactory;
import org.xtext.industryempire.myDsl.SingleResource;
import org.xtext.industryempire.myDsl.SingleVehicle;
import org.xtext.industryempire.myDsl.Vehicles;
import org.xtext.industryempire.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.CITIES:
				sequence_Cities(context, (Cities) semanticObject); 
				return; 
			case MyDslPackage.CLAZZ_MODEL:
				sequence_ClazzModel(context, (ClazzModel) semanticObject); 
				return; 
			case MyDslPackage.FACTORIES:
				sequence_Factories(context, (Factories) semanticObject); 
				return; 
			case MyDslPackage.RESOURCES:
				sequence_Resources(context, (Resources) semanticObject); 
				return; 
			case MyDslPackage.SINGLE_FACTORY:
				sequence_SingleFactory(context, (SingleFactory) semanticObject); 
				return; 
			case MyDslPackage.SINGLE_RESOURCE:
				sequence_SingleResource(context, (SingleResource) semanticObject); 
				return; 
			case MyDslPackage.SINGLE_VEHICLE:
				sequence_SingleVehicle(context, (SingleVehicle) semanticObject); 
				return; 
			case MyDslPackage.VEHICLES:
				sequence_Vehicles(context, (Vehicles) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Element returns Cities
	 *     Cities returns Cities
	 *
	 * Constraint:
	 *     (name+=ID x=INT y=INT factory+=[SingleFactory|ID]* factory+=[SingleFactory|ID]*)
	 */
	protected void sequence_Cities(ISerializationContext context, Cities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClazzModel returns ClazzModel
	 *
	 * Constraint:
	 *     element+=Element+
	 */
	protected void sequence_ClazzModel(ISerializationContext context, ClazzModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Factories
	 *     Factories returns Factories
	 *
	 * Constraint:
	 *     factories+=SingleFactory*
	 */
	protected void sequence_Factories(ISerializationContext context, Factories semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Resources
	 *     Resources returns Resources
	 *
	 * Constraint:
	 *     resources+=SingleResource*
	 */
	protected void sequence_Resources(ISerializationContext context, Resources semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleFactory returns SingleFactory
	 *
	 * Constraint:
	 *     (name=ID input=[SingleResource|ID]? output=[SingleResource|ID]?)
	 */
	protected void sequence_SingleFactory(ISerializationContext context, SingleFactory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleResource returns SingleResource
	 *
	 * Constraint:
	 *     (name=ID cost=INT)
	 */
	protected void sequence_SingleResource(ISerializationContext context, SingleResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_RESOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_RESOURCE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_RESOURCE__COST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_RESOURCE__COST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleResourceAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSingleResourceAccess().getCostINTTerminalRuleCall_4_0(), semanticObject.getCost());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SingleVehicle returns SingleVehicle
	 *
	 * Constraint:
	 *     (name=ID speed=INT load=INT tankSize=INT fuelConsumption=DOUBLE)
	 */
	protected void sequence_SingleVehicle(ISerializationContext context, SingleVehicle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__SPEED));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__LOAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__LOAD));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__TANK_SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__TANK_SIZE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__FUEL_CONSUMPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SINGLE_VEHICLE__FUEL_CONSUMPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleVehicleAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSingleVehicleAccess().getSpeedINTTerminalRuleCall_4_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getSingleVehicleAccess().getLoadINTTerminalRuleCall_8_0(), semanticObject.getLoad());
		feeder.accept(grammarAccess.getSingleVehicleAccess().getTankSizeINTTerminalRuleCall_12_0(), semanticObject.getTankSize());
		feeder.accept(grammarAccess.getSingleVehicleAccess().getFuelConsumptionDOUBLEParserRuleCall_16_0(), semanticObject.getFuelConsumption());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Vehicles
	 *     Vehicles returns Vehicles
	 *
	 * Constraint:
	 *     vehicles+=SingleVehicle*
	 */
	protected void sequence_Vehicles(ISerializationContext context, Vehicles semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
